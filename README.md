# Templating using Cookiecutter

This is a simple example of how to use `cookiecutter` to create a new project from a template.

## Installation

In your preferred virtual environment, install `cookiecutter` using `pip`:

```bash
python3.12 -m venv .venv --prompt=cookiecutter
source .venv/bin/activate
python -m pip install cookiecutter
```

## Usage

You can find the official documentation [here](https://cookiecutter.readthedocs.io/en/stable/index.html) and the official website [here](https://www.cookiecutter.io).

Using `cookiecutter` is straightforward. Your template consists of a folder containing Jinja2-based templating files. At the root of this folder, a `cookiecutter.json` file defines the default variables used in your template.

You can invoke `cookiecutter` using a Git repository, a local folder, or a ZIP file.

For example, if you have cloned the OpenCTI-connectors repository and your templates are located in `./templates/cookiecutter`, you can run:

```bash
> cookiecutter ./Opencti-connectors/templates/cookiecutter -o /tmp/example_cookiecutter
```

### `cookiecutter.json` Variables

The `cookiecutter.json` file defines the template variables:

```json

{
  "_connector_version": "6.5.2",
  "connector_name": "template",
  "__connector_name_snakecase": "{{ cookiecutter.connector_name|replace(' ', '_')|lower }}",
  "__connector_name_kebabcase": "{{ cookiecutter.connector_name|replace(' ', '-')|lower }}",
  "__connector_name_camelcase": "{{ cookiecutter.connector_name|title|replace(' ', '') }}",
  "connector_type":  ["external-import", "internal-enrichment", "internal-export-file", "internal-import-file", "stream"],
  "__connector_type_snakecase": "{{ cookiecutter.connector_type|replace('-', '_')|lower }}",
  "__connector_type_humancase": "{{ cookiecutter.connector_type|replace('-', ' ')|title }}"
}
```

When running `cookiecutter`, you will be prompted for `connector_name` and `connector_type` in a nicely formatted way:

```bash
>
  [1/2] connector_name (template): My exAmPle   
  [2/2] Select connector_type
    1 - external-import
    2 - internal-enrichment
    3 - internal-export-file
    4 - internal-import-file
    5 - stream
    Choose from [1/2/3/4/5] (1): 1
```

### Generated Project Structure

The generated project will have the following structure:

```bash
> tree /tmp/example_cookiecutter/
/tmp/example_cookiecutter/
└── my-example
    ├── Dockerfile
    ├── README.md
    ├── docker-compose.yml
    ├── entrypoint.sh
    ├── src
    │   ├── config.yml.sample
    │   ├── external_import_connector
    │   │   ├── __init__.py
    │   │   ├── client_api.py
    │   │   ├── config_loader.py
    │   │   ├── connector.py
    │   │   ├── converter_to_stix.py
    │   │   └── utils.py
    │   ├── main.py
    │   └── requirements.txt
    └── tests
        ├── __init__.py
        ├── common_fixtures.py
        ├── fixtures
        │   └── data_sample.json
        ├── test-requirements.txt
        └── test_my_example_connector.py

6 directories, 18 files
```

This structure helps streamline project creation, especially when dealing with recurring boilerplate code.

I've showned you the tree, but you can also see the content of the files are generated by the template too.

An example of `docker-compose.yml` generated by the template:

```yaml
version: '3'
services:
  connector-my-example:
    image: opencti/connector-my-example:6.5.2
    environment:
      # Connector's generic execution parameters
      - OPENCTI_URL=http://localhost
      - OPENCTI_TOKEN=CHANGEME
      # Connector's definition parameters REQUIRED
      - CONNECTOR_ID=CHANGEME
      - CONNECTOR_NAME=CHANGEME
      - CONNECTOR_SCOPE=CHANGEME
      - CONNECTOR_LOG_LEVEL=error
      - CONNECTOR_DURATION_PERIOD=CHANGEME # ISO8601 format in String, start with 'P...' for Period

      # Connector's definition parameters OPTIONAL
      # - CONNECTOR_QUEUE_THRESHOLD=500 # Default 500Mo, Float accepted
      # - CONNECTOR_RUN_AND_TERMINATE=False # Default False, True run connector once
      # - CONNECTOR_SEND_TO_QUEUE=True # Default True
      # - CONNECTOR_SEND_TO_DIRECTORY=False # Default False
      # - CONNECTOR_SEND_TO_DIRECTORY_PATH=CHANGEME # if CONNECTOR_SEND_TO_DIRECTORY is True, you must specify a path
      # - CONNECTOR_SEND_TO_DIRECTORY_RETENTION=7 # Default 7, in days

      # Connector's custom execution parameters
      - CONNECTOR_MY_EXAMPLE_API_BASE_URL=CHANGEME
      - CONNECTOR_MY_EXAMPLE_API_KEY=CHANGEME
      - CONNECTOR_MY_EXAMPLE_TLP_LEVEL=CHANGEME # available values are: clear, white, green, amber, amber+strict, red - Default: 'clear'

      # Add proxy parameters below if needed
      # - HTTP_PROXY=CHANGEME
      # - HTTPS_PROXY=CHANGEME
      # - NO_PROXY=CHANGEME
    restart: always
    # networks:
    #   - docker_default

# networks:
#   default:
#     external: true
#     name: docker_default
```

## Advantages

- **Centralized Templates**: Maintain a single source of truth for boilerplate code.
- **Consistency**: Ensures uniform structure and formatting across projects.
- **Cross-Platform**: Works anywhere Python is installed, unlike shell scripts that are limited to Linux.

## Conclusion

Using `cookiecutter` simplifies project creation by automating template generation. This example illustrates its usefulness in setting up OpenCTI connectors, but its applications extend to any project requiring structured templating.

For more details, refer to the [official documentation](https://cookiecutter.readthedocs.io/en/stable/index.html).


